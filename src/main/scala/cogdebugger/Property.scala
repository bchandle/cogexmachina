/*
 * (c) Copyright 2016 Hewlett Packard Enterprise Development LP
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cogdebugger

import scala.swing._
import cogdebugger.ui.components.Spinner
import scala.swing.event.{SelectionChanged, ValueChanged}
import scala.language.existentials

/*
 * Created with IntelliJ IDEA.
 * User: gonztobi
 * Date: 9/30/13
 * Time: 2:11 PM
 */

/** Represents part of the state of some GUI element (e.g. the zoom level of
  * a visualization). Meant to help assist with preservation of UI settings
  * and appearance across application runs.
  *
  * Setting a Property's value will cause the onPropertyChanged method to be
  * called, which by default calls the apply method of the installed
  * scala.swing.Action. The default Action, however, is
  * scala.swing.Action.NoAction, which of course does nothing. Either
  * install an appropriate Action or override onPropertyChanged if you want
  * to trigger some behavior when the value of the Property is changed.
  *
  * Each property can produce an XML tag suitable for saving into a properties
  * file, and can later parse that tag to restore the previous state. */
abstract class Property[T](
    val name: String,
    var action: Action,
    initialValue: T)
  extends Action.Trigger
  with Publisher
{

  def this(name: String, initialValue: T) = this(name, Action.NoAction, initialValue)
  def this(action: Action, initialValue: T) = this(action.title, action, initialValue)

  protected var _value = initialValue
  def value = _value
  def value_=(newValue: T) {
    val oldValue = value
    _value = newValue
    publish(PropertyValueChanged(this, oldValue, value))
    onPropertyChange(value, newValue)
  }

  def onPropertyChange(oldValue: T, newValue: T) { action.apply() }

  /** A String name for the type this Property represents. Used in a runtime
    * check to safeguard against using the restore method from a different
    * Property subclass on the XML generated by this Property. */
  protected def typeString: String // Can we just classOf[T].toString or something?

  def xmlTag = <property name={ name } type={ typeString }>{ value }</property>
  def parseText(text: String): Option[T]
  def restore(node: scala.xml.Node) {
    if (node.label == "property" && (node \ "@type").text == typeString) {
      parseText(node.text) match {
        case Some(newValue) => value = newValue
        case None => Console.err.println("Bad value")// Warning? Exception?
      }
    } else {
      // Invalid XML node. Post warning? Exception?
    }
  }
}

case class PropertyValueChanged[T](source: Property[_], oldValue: T, newValue: T)
  extends scala.swing.event.Event

class BooleanProperty(name: String, initialValue: Boolean) extends Property[Boolean](name, initialValue) {
   val typeString = "boolean"
  def parseText(text: String): Option[Boolean] = Some(java.lang.Boolean.parseBoolean(text))
  def toggle() { value = !value }
}

class IntProperty(name: String, initialValue: Int) extends Property[Int](name, initialValue) {
  val typeString = "int"
  def parseText(text: String): Option[Int] = {
    var result: Option[Int] = None
    try {
      result = Some(java.lang.Integer.parseInt(text))
    } catch {
      case e: NumberFormatException =>
    }
    result
  }
}

/** Represents a single floating point value. Can be rendered as a spinner
  * by [[cogdebugger.ToolFactory]]. */
class FloatProperty(name: String, initialValue: Float) extends Property[Float](name, initialValue) {
  val typeString = "float"
  def parseText(text: String): Option[Float] = {
    var result: Option[Float] = None
    try {
      result = Some(java.lang.Float.parseFloat(text))
    } catch {
      case e: NumberFormatException =>
    }
    result
  }
}

class DoubleProperty(name: String, initialValue: Double) extends Property[Double](name, initialValue) {
  val typeString = "double"
  def parseText(text: String): Option[Double] = {
    var result: Option[Double] = None
    try {
      result = Some(java.lang.Double.parseDouble(text))
    } catch {
      case e: NumberFormatException =>
    }
    result
  }
}

/** Represents a finite number of states, of which only one is active. Can be
  * rendered as a combobox by [[cogdebugger.ToolFactory]]. */
class OneOfNProperty(name: String, initialValue: String, val options: List[String]) extends Property[String](name, initialValue) {
  require(options.contains(initialValue))
  def selection = value
  def selection_=(newValue: String) { value = newValue }
  override def value_=(newValue: String) {
    // Only accept values defined in options
    if (options.contains(newValue)) super.value_=(newValue)
  }
  protected def typeString: String = "OneOfN"
  def parseText(text: String): Option[String] = Some(text)
}

class StringProperty(name: String, initialValue: String) extends Property[String](name, initialValue) {
  val typeString = "string"
  def parseText(text: String): Option[String] = Option(text)
}

/** A factory that makes GUI controls for the different types of Properties,
  * and sets them up to keep their states synched. That is, changes to the
  * property will cause the GUI elements to change state when appropriate, and
  * acting on the controls will change the values stored in the properties.
  *
  * This synching is implemented primarily for the benefit of XML resore
  * mechanism built into Properties; restoring the state of a Property from a
  * XML file will cause its associated UI elements to be restored as well.
  */
object ToolFactory {

  /** Creates a ToggleButton for the given BooleanProperty */
  def toggle(property: BooleanProperty) = {
    val button = new ToggleButton()
    button.selected = property.value // Initial toggle state
    button.action = Action(property.name) { property.value = button.selected } // Changes to toggle state reflected in property
    button.listenTo(property) // Changes to property reflected in button
    button.reactions += { case PropertyValueChanged(`property`, _, _) => button.selected = property.value }
    button
  }

  /** Creates a Spinner for the given IntProperty */
  def spinner(property: IntProperty, min: Int, max: Int, stepSize: Int) = {
    val model = new javax.swing.SpinnerNumberModel(property.value, min, max, stepSize)
    val spinner = buildSpinner(property, model)
    spinner.reactions += { case ValueChanged(`spinner`) => property.value = spinner.value.asInstanceOf[Number].intValue() }
    spinner
  }

  /** Creates a Spinner for the given FloatProperty */
  def spinner(property: FloatProperty, min: Float, max: Float, stepSize: Float) = {
    // Without the cast to Comparables, this will use the constructor
    // specialized for doubles, which causes errors when clicking the errors
    // (something about Float can't be cast to Double -- what!?).
    val model = new javax.swing.SpinnerNumberModel(property.value, min.asInstanceOf[Comparable[_]], max.asInstanceOf[Comparable[_]], stepSize)
    val spinner = buildSpinner(property, model)
    spinner.reactions += { case ValueChanged(`spinner`) => property.value = spinner.value.asInstanceOf[Number].floatValue() }
    spinner
  }

  /** Creates a Spinner for the given FloatProperty */
  def spinner(property: DoubleProperty, min: Double, max: Double, stepSize: Double) = {
    val model = new javax.swing.SpinnerNumberModel(property.value, min, max, stepSize)
    val spinner = buildSpinner(property, model)
    spinner.reactions += { case ValueChanged(`spinner`) => property.value = spinner.value.asInstanceOf[Number].doubleValue() }
    spinner
  }

  /** Creates a ComboBox for the given OneOfNProperty */
  def comboBox(property: OneOfNProperty) = {
    val combobox = new ComboBox[String](property.options)
    combobox.selection.item = property.selection

    // This could perhaps be done better. When the combobox selection changes,
    // it will change the state of `property`, which raises an event... that
    // sets the combobox selection to whatever it already is. Fortunately,
    // swing has a built-in mechanism to prevent endless event loops. All that
    // to say, the below reaction setup is a bit redundant, but it seems to be
    // harmless.
    property.listenTo(combobox.selection)
    property.reactions += { case SelectionChanged(`combobox`) => property.selection = combobox.selection.item }
    combobox.listenTo(property)
    combobox.reactions += { case PropertyValueChanged(`property`, _, _) => combobox.selection.item = property.selection }

    combobox
  }

  /** Builds a Spinner and connects it to the given Property so that changes
    * to the spinner affect the Property.. */
  private def buildSpinner(property: Property[_], model: javax.swing.SpinnerNumberModel) = {
    val spinner = new Spinner(model)
    spinner.value = property.value // Set initial value
    spinner.listenTo(property)     // Reflect changes in the Property
    spinner.reactions += { case PropertyValueChanged(`property`, _, _) => spinner.value = property.value }
    spinner
  }

}