/*
 * (c) Copyright 2016 Hewlett Packard Enterprise Development LP
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cogx.platform.types

import cogx.cogmath.hypercircuit.{Hyperedge, Hypernode}
import cogx.compiler.codegenerator.opencl.cpukernels._
import cogx.compiler.parser.op.{FieldReduceMedianOp, OuterProductOp}
import cogx.platform.checkpoint.{ObjectRestorer, RestoreFactory, Saveable, ObjectSaver}
import cogx.platform.opencl.OpenCLRestoredDeviceKernel
import cogx.platform.types.KernelCodeTypes.KernelCodeType
import cogx.platform.types.KernelTypes._
import cogx.runtime.{ComputeGraphSaverState, ComputeGraphRestorerState}

import scala.collection.mutable.ArrayBuffer

/** Base class for all kernels, CPU or Device, for all platforms (CUDA or
  * OpenCL)
  *
  * This manages connectivity between kernels, allowing kernels to be connected
  * and disconnected.  The responsibility for adding output edges is left to
  * the subclasses.
  *
  * @param opcode The operation performed by this kernel.
  * @param _inputs The virtual field registers driving the inputs of this kernel.
  * @param fieldTypes The types of the results generated by this kernel.
  *
  * @author Greg Snider
  */
private[cogx]
abstract class AbstractKernel(val opcode: Opcode,
                              _inputs: Array[VirtualFieldRegister],
                              val fieldTypes: Array[FieldType])
  extends Hypernode[AbstractKernel](_inputs.asInstanceOf[Array[Hyperedge[AbstractKernel]]])
  with Saveable
{
  /** The language of the kernel.  This should reside in a platform-independent
    * subclass of AbstractKernel named 'DeviceKernel' and there should be no
    * platform-dependent CPU kernels (e.g. OpenCLCpuKernel), but such is life.
    */
  val kernelCodeType: KernelCodeType

  /** The type of the kernel, either DeviceKernel, or one of a number of CPU kernel types. */
  val kernelType: KernelType

  /** Unique ID for each Kernel. */
  val id = AbstractKernel.allocateID

  /* "Alias" is probably not the right word to use here. This is a quick fix
   * for a debugger issue that arises when we distribute a graph across
   * multiple nodes. During partioning of the user's compute graph, we copy
   * kernels from the unpartioned graph to subcircuits (as the original
   * circuit's structure is immutable and can't be broken apart). The
   * subcircuits are what is bound to compute devices, but the debugger gets
   * the original, unpartitioned graph. The kernels the debugger knows about
   * aren't actually bound to a compute device. It needs a mapping from the
   * kernels in the original circuit to their copies that have been distributed
   * throughout the cluster. That's what these "aliases" are for. If we copy
   * a kernel to a subcircuit, we add the copy's ID here. Realistically, we'd
   * expect that there's only ever a single copy (a single kernel probably
   * shouldn't be distributed to multiple nodes, except perhaps for some sort
   * of failure recovery mechanism?), but as there's nothing currently
   * preventing a kernel from being copied multiple times, I've set this up
   * for allowing multiple aliases. */
  private var _aliases = collection.mutable.Set.empty[Int]
  def aliases: Option[Set[Int]] = if (_aliases.size == 0) None else Some(_aliases.toSet)
  def addAlias(id: Int) { _aliases += id }

  /** The inputs to this kernel, as VirtualFieldRegisters, not as the base class
    * Hyperedge[AbstractKernel]
    */
  override def inputs = super.inputs.asInstanceOf[Seq[VirtualFieldRegister]]

  /** The outputs to this kernel, as VirtualFieldRegisters, not as the base class
    * Hyperedge[AbstractKernel]
    */
  override def outputs = super.outputs.asInstanceOf[Seq[VirtualFieldRegister]]

  /** Check if any output register of the kernel is "probed".
    *
    * A probed field register cannot be optimized away and is guaranteed to be
    * visible.
    *
    * @return True if any output register of the kernel is probed.
    */
  def probed = outputs.exists(_.probed)

  /** Mark all of the kernel outputs as probed. Once marked, it cannot be unprobed. */
  def markProbed() {
    outputs.foreach(_.markProbed)
  }

  /** Mark a single kernel output as probed. Once marked, it cannot be unprobed. */
  def markProbed(outputIndex: Int) {
    outputs(outputIndex).markProbed
  }

  /** Get the name of the kernel (usually the name of its single output) */
  def name = outputs.map(_.name).mkString("|")

  /** Synonym for the input kernels to this kernel. */
  def children = inputs.map(_.source)

  /** Test "this" and "other" for deep equality, allowing "==" to work.
    *
    * Two AbstractKernels are equal if: (1) they have the same opcode; and
    * (2) they have the same input field registers.
    *
    * @return Tr
    */
  final override def equals(other: Any): Boolean = {
    other match {
      case that: AbstractKernel =>
        if (that eq this)
          true
        else if ((that canEqual this) && (that.opcode == this.opcode) &&
            (that.inputs.length == this.inputs.length) &&
            (that.outputs.length == this.outputs.length) &&
            (this.outputs zip that.outputs).forall(x => x._1.fieldType == x._2.fieldType))
        {
          // Because of the use of 'eq' here, common sub expressions will be
          // consolidated from the leaves toward the roots.
          // Equal kernels must be sourced from the same VirtualFieldRegisters.
          for (i <- 0 until inputs.length) {
            if (!(this.inputs(i) eq that.inputs(i)))
              return false
          }
          true
        }
        else
          false
      case _ => false
    }
  }

  /** Helper for equals. Default canEqual requires that the two objects are the
    * same subclass of AbstractKernel. Subclasses may override this if a more
    * restrictive equality is required.
    */
  def canEqual(other: Any): Boolean = {
    other.isInstanceOf[AbstractKernel] &&
            other.asInstanceOf[AbstractKernel].getClass == this.getClass
  }

  /** Required because of overriding equals. This can be tricky.  Two objects
    * that might be 'equal' should have the same hashcode.  A kernel that has been
    * entered into a HashMap, then has an input replaced with an equal kernel
    * should not have its hash changed.  However the field register would change
    * during such a replacement.  Thus, the kernel 'hashCode'
    * shouldn't involve the intervening field registers. */
  override val hashCode: Int = {
    var code = getClass.hashCode
    for (in <- inputs) {
      if (in != null && in.source != null)
          code += in.source.hashCode
    }
    def fieldTypeHash =
      fieldTypes.zipWithIndex.map(x => x._1.hashCode * x._2).foldLeft(0)(_ + _)
    code += opcode.hashCode + 41 * (inputs.length + 41 * (fieldTypeHash + 41))
    code
  }

  /** Create a clone of this kernel that uses a new set of virtual field registers
    *  as inputs.  Useful for breaking a large circuit apart into smaller subcircuits. */
  def copyWithNewInputs(inputs: Array[VirtualFieldRegister]): AbstractKernel

  /** Save this AbstractKernel instance using the facilities of the ObjectSaver */
  def save(saver: ObjectSaver) {
    val saverState = saver.asInstanceOf[ComputeGraphSaverState]
    import saverState._
    // A map from VirtualFieldRegister to its index, created as the kernels are saved.
    // Inputs of this kernel should be part of the map already, so simply look up their indices.
    val inputIndices = inputs.map(vfrToIndex(_)).toArray
    // Outputs of this kernel should be part of the map already, so simply look up their indices.
    val outputIndices = outputs.map(vfrToIndex(_)).toArray
    saver.writeInt("kernelId", id)
    saver.writeString("kernelType", kernelType.toString)
    kernelType match {
      case UnrestorableKernelType =>
        println("Error: The following kernel is not restorable: " + this.toString)
      case _ =>
        if (!kernelType.supportedByNativeRuntime)
          println("Warning: The following kernel is not restorable within the native runtime: " + this.toString)
    }
    saver.writeIntArray("inputFields", inputIndices)
    saver.writeIntArray("outputFields", outputIndices)
  }
}

/** Companion for AbstractKernel that generates unique IDs.
  */
private[cogx]
object AbstractKernel extends RestoreFactory {
  /** Number of allocated AbstractKernels. */
  private var allocated = 0

  /** Allocate a unique ID for an AbstractKernel. */
  private def allocateID: Int = {
    allocated += 1
    allocated
  }

  /** Create an AbstractKernel instance through use of the provided ObjectRestorer
    *
    * @param restorer The restorer through which to read the new object state.
    * @return The created AbstractKernel based on the read information.
    */
  def restore(restorer: ObjectRestorer) = {
    val restorerState = restorer.asInstanceOf[ComputeGraphRestorerState]
    import restorerState._
    val kernelId = restorer.readInt("kernelId")
    val kernelType = restorer.readString("kernelType")
    val inputIndices = restorer.readIntArray("inputFields")
    val outputIndices = restorer.readIntArray("outputFields")
    // inputs should already have been encountered and added to the global 'vfrs' collection:
    val inputRegisters = inputIndices.map(vfrs(_))
    val outputFieldTypes = outputIndices.map(fieldInfos(_).fieldType)
    // Check output indices to make sure the vfrs collection is in sync:
    for (i <- 0 until outputIndices.length) {
//      println(s"i = $i, outputIndices = ${outputIndices(i)}, vfrs.length = ${vfrs.length}")
      require(outputIndices(i) == vfrs.length + i,
        "Internal error: inconsistency in output VirtualFieldRegister count.")
    }
    // Trust for now that kernelIds are unique.  Set up the allocated variable to give the next created
    // kernel the proper Id.  Note that kernels won't be numbered densely and consecutively because of kernel merging.
    allocated = kernelId - 1

    val newKernel = KernelTypes(kernelType) match {
      case DeviceKernelType =>
        OpenCLRestoredDeviceKernel.restore(restorer, kernelId, inputRegisters, outputFieldTypes)
      case RecurrenceKernelType =>
        require(inputRegisters.length == 0)
        require(outputFieldTypes.length == 1)
        RecurrentFieldKernel.restore(restorer, outputFieldTypes(0))
      case ConstantKernelType =>
        require(inputRegisters.length == 0)
        require(outputFieldTypes.length == 1)
        ConstantFieldKernel.restore(restorer, outputFieldTypes(0))
      case SensorKernelType =>
        require(inputRegisters.length == 0)
        require(outputFieldTypes.length == 1)
        SensorKernelRestorer.restore(restorer, outputFieldTypes(0))
      case ActuatorKernelType =>
        require(inputRegisters.length == 1)
        require(outputFieldTypes.length == 0)
        ActuatorKernelRestorer.restore(restorer, inputRegisters(0))
      case CPUOuterProductKernelType =>
        CPUOuterProductKernel(inputRegisters, OuterProductOp, outputFieldTypes(0))
      case CPUScalarReduceMedianKernelType =>
        CPUScalarReduceMedianKernel(inputRegisters(0), FieldReduceMedianOp, outputFieldTypes(0))
      case x => throw new RuntimeException(s"Can't currently restore kernel $kernelId, kernel type $x")
    }
    newKernel.outputs.foreach(vfrs += _)
    // Transfer the saved vfr info (field name and whether it's probed or not) to the restored kernel's outputs
    for (i <- 0 until newKernel.outputs.length) {
      val outputInfo = fieldInfos(outputIndices(i))
      if (outputInfo.probed)
        newKernel.outputs(i).markProbed()
      newKernel.outputs(i).name = outputInfo.name
    }
    newKernel
  }

}
