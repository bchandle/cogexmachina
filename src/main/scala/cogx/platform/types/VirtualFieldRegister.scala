/*
 * (c) Copyright 2016 Hewlett Packard Enterprise Development LP
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cogx.platform.types

import cogx.cogmath.hypercircuit.Hyperedge
import cogx.platform.checkpoint.{ObjectRestorer, RestoreFactory, Saveable, ObjectSaver}

/** Base class for the "signal wire" that passes between a kernel output and any
  * kernel input that "sinks" the signal, for all platforms (CUDA or OpenCL).
  * 
  * The class name includes the term "virtual" because real allocated registers may be
  * shared among the virtual registers that are part of the KernelCircuit.  The
  * real registers are "bound" to potentially multiple virtual registers.
  *
  * Creating a VirtualFieldRegister will add the register as an additional
  * output to the `sourceKernel`.
  *
  * @param fieldType The type of the result generated by this kernel.
  * @param sourceKernel The abstract kernel driving this register.
  *
  * @author Dick Carter
  */
private[cogx]
class VirtualFieldRegister(val fieldType: FieldType,
                           sourceKernel: AbstractKernel)
  extends Hyperedge[AbstractKernel](sourceKernel) with Saveable
{
   private var _register: FieldRegister[_] = null

  /** True if this register is "probed", meaning it cannot be optimized away. */
  private var _probed = false

  /** Name of a virtual field register, for debugging. */
  private var _name = ""

  /** bind an actual (possible shared) FieldRegister to this virtual one. */
  def bindRegister(r: FieldRegister[_]) { _register = r }

  /** The actual (possible shared) FieldRegister bound to this virtual one. */
  def register = _register

  /** Check if register is "probed".
    *
    * A probed field register cannot be optimized away and is guaranteed to be
    * visible.
    *
    * @return True if register is probed.
    */
  def probed =
    _probed

  /** Mark a field register as probed. Once marked, it cannot be unprobed. */
  def markProbed() {
    _probed = true
  }

  /** Get the name of the virtual field register. */
  def name = _name

  /** Assign a name to the virtual field register. */
  def name_=(name: String) {_name = name}


  /** Copy over the name and merge the probed status from another VirtualFieldRegister. */
  def stealProbeAndNameFrom(that: VirtualFieldRegister) {
    name = that.name
    if (that.probed)
      markProbed()
  }

  /** Save this VirtualFieldRegister instance using the facilities of the ObjectSaver */
  def save(saver: ObjectSaver) {
    saver.writeString("name", _name)
    saver.writeInt("probed", if (_probed) 1 else 0)
    saver.writeObject("fieldType", fieldType)
  }
}

/** Helper class to hold VirtualFieldRegister info before actually instantiating one. */
case class VirtualFieldRegisterInfo(val name: String, val probed: Boolean, val fieldType: FieldType)

object VirtualFieldRegister extends RestoreFactory {

  /** Create a VirtualFieldRegisterInfo instance through use of the provided ObjectRestorer.
    * Note that we don't want to create the VirtualFieldRegisters themselves: they get created as
    * part of the AbstractKernel creation.
    *
    * @param restorer The restorer through which to read the new object state.
    * @return The created VirtualFieldRegisterInfo based on the read information.
    */
  def restore(restorer: ObjectRestorer) = {
    val name = restorer.readString("name")
    val probed = restorer.readInt("probed") match {
      case 1 => true
      case 0 => false
      case x => throw new RuntimeException("Unexpected integer value for boolean 'probed': " + x)
    }
    val fieldType = restorer.readRestorable("fieldType", FieldType).asInstanceOf[FieldType]
    VirtualFieldRegisterInfo(name, probed, fieldType)
  }
}
