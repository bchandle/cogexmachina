/*
 * (c) Copyright 2016 Hewlett Packard Enterprise Development LP
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cogx.platform.opencl

import cogx.parameters.Cog
import cogx.platform.checkpoint.{Saveable, ObjectSaver}
import cogx.platform.types.KernelTypes.{DeviceKernelType, KernelType}
import cogx.runtime.ComputeGraphSaverState
import com.jogamp.opencl._
import cogx.platform.types.{VirtualFieldRegister, FieldType, Opcode}
import cogx.platform.opencl.OpenCLEventCache._

import scala.collection.mutable

/** Base class for a kernel which runs on an OpenCL device.
  *
  * @param opcode The operation performed by this kernel.
  * @param in The virtual field registers driving the inputs of this kernel.
  * @param resultTypes The types of the results generated by this kernel.
  *
  * @author Greg Snider
  */
private[cogx]
abstract class OpenCLDeviceKernel(opcode: Opcode,
                            in: Array[VirtualFieldRegister],
                            val resultTypes: Array[FieldType])
  extends OpenCLAbstractKernel(opcode, in, resultTypes)
  with Saveable
{
  /** The type of the kernel, either DeviceKernel, or one of a number of CPU kernel types. */
  val kernelType = DeviceKernelType

  /** Code for OpenCL kernel. */
  def kernelCode: String
  /** Work group parameters for executing the kernel. */
  val workGroup: WorkGroupParameters
  /** Input events that must happen before computation can start. */
  private val inputTriggers = new Array[CLEvent](in.length)
  /** Output event triggered when computation finished. */
  outputTrigger = new CLEventList(CLEventFactory, 1)

  /** Create a short string for debugging. */
  override def toString: String =
    "OpenCLDeviceKernel_" + id + "(" + opcode.toString + ")"

  /** Reset / initialize the kernel state.  */
  final def reset() {
  }

  /** Asynchronously start execution of a kernel when all `inputTriggers` have
    * completed, generating an outputTrigger when execution is completed.
    */
  final def phase1Clock() {
    for (outputRegister <- outputRegisters) {
      outputRegister.master.invalidateCpuMemory
    }
    require(clKernel != null, "missing clKernel in " + toString)

    // Get input events. Note that we must skip over recurrences

    // TODO: rather than having the triggers be the "doneness" of the input
    // kernels, this kernel should ask the input registers if they are
    // "readyForGPURead".  Some data-set-copying smarts can be built into
    // the registers as they ask their source-kernel for their "doneness".  -RJC
    for (i <- 0 until in.length) {
      inputTriggers(i) = in(i).source.asInstanceOf[OpenCLAbstractKernel].done.getEvent(0)
    }

    // Attach the input and output buffers to the kernel. These can be changed
    // on each clock tick, so they must be attached every time.
    clKernel.rewind
    for (register <- inputRegisters)
      clKernel.putArg(register.slave.deviceBuffer)
    for (register <- outputRegisters)
      clKernel.putArg(register.master.deviceBuffer)

    // Create the event list that the kernel must wait on before executing
    val waitFor =
      if (inputTriggers.size > 0)
        new CLEventList(CLEventFactory, inputTriggers: _*)
      else
        null.asInstanceOf[CLEventList]

    // Start the kernel executing.
    launchKernel(clKernel, workGroup, waitFor, outputTrigger)
  }

  /** Check the result of the computation, making sure it completed correctly,
    * and initialize resources for next computation cycle. Must be called after
    * the done event is complete.
    */
  final def phase2Clock() {
    val event = outputTrigger.getEvent(0)
    try {
      // event.getStatus() may throw a CLException if the error is unknown
      event.getStatus match {
        case CLEvent.ExecutionStatus.ERROR =>
          throw new RuntimeException(toString + " " + name +
            " fails with error code " + event.getStatusCode)
        case CLEvent.ExecutionStatus.COMPLETE =>
          if (commandQueue.profile) {
            val DebugProfileInfoWierdness = false
            if (DebugProfileInfoWierdness)
              debugProfileInfoWierdness(event)
            else {
              val startNanos = event.getProfilingInfo(CLEvent.ProfilingCommand.START)
              val endNanos = event.getProfilingInfo(CLEvent.ProfilingCommand.END)
              val durationUsecs = (endNanos - startNanos) / 1000.0
              stats.addSample(durationUsecs)
            }
          }
        case other =>
          throw new RuntimeException("Unexpected status for " + toString +
            ": " + other + " (expecting COMPLETE)")
      }
    }
    catch {
      case e: CLException =>
        throw new RuntimeException(toString + " " + name +
          " fails by throwing exception: " + e)
    }
    outputTrigger.release()
  }

  /** Legacy routine used to debug strange (non-causal) NVIDIA profiling times circa 2014. */
  private def debugProfileInfoWierdness(event: CLEvent): Unit = {
    // This is set to print out wierdnesses in the OpenCL profiling data,
    // as was seen initially with NVIDIA.  This was localalized to user
    // events modified by cpu-kernel threads that were different from
    // the main GPUSupervisor thread.  Now that we think we understand
    // and have corrected the main cause, we leave this enabled to
    // identify secondary causes.  The code below can be reduced greatly
    // once we feel the profiling system is solid.

    // Times that are available to measure: QUEUED, SUBMIT, START, END.
    val queuedNanos = event.getProfilingInfo(CLEvent.ProfilingCommand.QUEUED)
    val submitNanos = event.getProfilingInfo(CLEvent.ProfilingCommand.SUBMIT)
    val startNanos = event.getProfilingInfo(CLEvent.ProfilingCommand.START)
    val endNanos = event.getProfilingInfo(CLEvent.ProfilingCommand.END)
    val durationUsecs = (endNanos - startNanos) / 1000.0
    val InsanelyLongTimeUsecs = 10 * 1000000.0
    if (queuedNanos >= submitNanos ||
      submitNanos >= startNanos ||
      startNanos >= endNanos ||
      durationUsecs > InsanelyLongTimeUsecs) {            // 10 seconds
      if (queuedNanos >= submitNanos)
        println("queued->submit = " + (submitNanos - queuedNanos))
      if (submitNanos >= startNanos)
        println("submit->start = " + (startNanos - submitNanos))
      if (startNanos >= endNanos)
        println("start->end = " + (endNanos - startNanos))
      println("**********************************************")
      println("queued =     " + queuedNanos)
      println("submit =     " + submitNanos)
      println("startnanos = " + startNanos)
      println("endnanos =   " + endNanos)
      println("**********************************************")
    }
    if (durationUsecs > 0.0 && durationUsecs <= InsanelyLongTimeUsecs)
      stats.addSample(durationUsecs)
    else
      stats.addOutlier()
  }


  /** Launch a kernel by enqueueing it onto a device command queue.
  *
  * @param clKernel The OpenCL kernel to be launched.
  * @param parms Work group parameters for the launch
  * @param conditionsForLaunch Events that must be triggered before this
  *        kernel can be launched.
  * @param done A CLEventList of length 1 containing a null event. This is
  *        filled in with an event.
  */
  private def launchKernel(clKernel: CLKernel, parms: WorkGroupParameters,
                         conditionsForLaunch: CLEventList, done: CLEventList)
  {
    //clCommandQueue.synchronized {
      parms.dimensions match {
        case 3 =>
          commandQueue.put3DRangeKernel(clKernel,
            0L, 0L, 0L,
            parms.globalColumns, parms.globalRows, parms.globalLayers,
            parms.localColumns, parms.localRows, parms.localLayers,
            conditionsForLaunch, done)
        case 2 =>
          commandQueue.put2DRangeKernel(clKernel,
            0L, 0L,
            parms.globalColumns, parms.globalRows,
            parms.localColumns, parms.localRows,
            conditionsForLaunch, done)
        case 1 =>
          commandQueue.put1DRangeKernel(clKernel,
            0L,
            parms.globalColumns,
            parms.localColumns,
            conditionsForLaunch, done)
        case x =>
          require(requirement = false,
            "Illegal dimensions for launchKernel: " + x)
      }
    //}
  }

  /** Save this instance using the facilities of the ObjectSaver */
  override def save(saver: ObjectSaver): Unit = {
    val saverState = saver.asInstanceOf[ComputeGraphSaverState]
    super.save(saver)
    saver.writeObject("workGroupParameters", workGroup)
    val ksc = new KernelSourceCode(kernelCode)
    val codeIndex = saverState.kernelCodeToIndex.get(ksc) match {
      case Some(i) => i
      case None => throw new RuntimeException(s"Internal error: kernel ${ksc.nameAsRun} missing from kernelcode database.")
    }
    saver.writeInt("kernelCodeIndex", codeIndex)
  }
}