/*
 * (c) Copyright 2016 Hewlett Packard Enterprise Development LP
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cogx.platform.opencl

import cogx.parameters.Cog
import cogx.platform.types.KernelTypes.{KernelType, UnrestorableKernelType}
import com.jogamp.opencl.CLEvent.ExecutionStatus
import com.jogamp.opencl._
import cogx.platform.types.{VirtualFieldRegister, FieldType, Opcode}
import cogx.platform.opencl.OpenCLEventCache._
import akka.actor.ActorRef

/** Base class for a kernel which runs on the CPU.
  *
  * @param opcode The operation performed by this kernel.
  * @param in The virtual field registers driving the inputs of this kernel.
  * @param fieldTypes The types of the results generated by this kernel.
  * @param needActor True if this kernel needs to run in an actor because it
  *        could potentially block, e.g. making system calls, or because it's
  *        desired to have more parallelism.
  *
  * @author Greg Snider
  */
private[cogx]
abstract class OpenCLCpuKernel(opcode: Opcode,
                               in: Array[VirtualFieldRegister],
                               fieldTypes: Array[FieldType],
                               needActor: Boolean = true)
  extends OpenCLAbstractKernel(opcode, in, fieldTypes)
{
  import OpenCLCpuKernel._
  /** The type of the kernel, either DeviceKernel, or one of a number of CPU kernel types. */
  val kernelType: KernelType = UnrestorableKernelType
  /** Input events that must happen before computation can start. */
  private val inputTriggers = new Array[CLEvent](in.length)
  /** Actor which runs this kernel, only used if `needActor` is true. */
  private var kernelActor: ActorRef = null

  val hasActor = needActor && !Cog.profile

  private[cogx] def injectActor(actor: ActorRef) {
    require(hasActor && kernelActor == null, "illegal actor injection")
    kernelActor = actor
  }

  /** Create a short string for debugging. */
  override def toString: String =
    "OpenCLCpuKernel_" + id + "(" + opcode.toString + ") => " + fieldTypesString +
          (if (name == "") name else " '" + name + "'") + ", inputs = " + inputFieldTypesString

  /** Asynchronously start execution of a kernel when all `inputTriggers` have
    * completed, generating an `outputTrigger` when execution is completed.
    */
  final def phase1Clock() {
    val userEvent = CLUserEvent.create(clContext)
    outputTrigger = new CLEventList(CLEventFactory, userEvent)

    // Collect all events that must be triggered before execution can begin.
    for (i <- 0 until in.length)
      inputTriggers(i) = in(i).source.asInstanceOf[OpenCLAbstractKernel].done.getEvent(0)

    val inputRegs = inputRegisters.toArray

    if (hasActor) {
      // Run in actor.
      val message =
        Step(inputTriggers,
          userEvent,
          inputRegs,
          outputRegisters)
      kernelActor ! message
    } else {
      // Run in-line.
      // Wait until input triggers occur.
      waitForEvents(inputTriggers)

      val startTime =
        if (Cog.profile && needActor)
          System.nanoTime()
        else
          0L

      // Do the computation. Pre- and Post-Compute hooks allow cpu kernels
      // like Sensors to signal 'complete' early, since Sensors are working
      // on the next cycle's input.

      // This should be similar handling of the compute() call as found in the CpuKernelActor code
      try {
        compute(inputRegs, outputRegisters)
        // Fire output events to enable computation by consumers
        userEvent.setComplete()
      }
      catch {
        case e: Exception =>
          println("CPU Kernel Actor " + this + " sees exeption: " + e)
          userEvent.setStatus(ExecutionStatus.ERROR)
      }

      if (Cog.profile && needActor) {
        val durationNanos = System.nanoTime() - startTime
        stats.addSample(durationNanos/1000f)
      }
    }
  }

  /** Check the result of the computation, making sure it completed correctly,
    * and initialize resources for next computation cycle. Must be called after
    * the done event is complete.
    */
  final def phase2Clock() {
    val event = outputTrigger.getEvent(0)
    try {
      // event.getStatus() may throw a CLException if the error is unknown
      event.getStatus match {
        case CLEvent.ExecutionStatus.ERROR =>
          throw new RuntimeException(toString + " " + name +
            " fails with error code " + event.getStatusCode)
        case CLEvent.ExecutionStatus.COMPLETE =>
        case other =>
          throw new RuntimeException("Unexpected status for " + toString +
            ": " + other + " (expecting COMPLETE)")
      }
    }
    catch {
      case e: CLException =>
        throw new RuntimeException(toString + " " + name +
          " fails by throwing exception: " + e)
    }
    outputTrigger.release()
  }

  /** Reset / initialize the kernel state.  */
  def reset() {
  }

  /** Code which the user kernel must execute. */
  def compute(in: Array[OpenCLFieldRegister], out: Array[OpenCLFieldRegister]): Unit

}

/** Actor messages for controlling an actor which runs a CPU kernel. */
object OpenCLCpuKernel {
  /** Advance the computation by one step.
    *
    * @param inputTriggers CLEvents that must be triggered before starting
    *        execution (this is why CPUKernelActors have their own threads).
    * @param outputTrigger CLUserEvent that must be triggered when execution
    *        a compute cycle completes.
    * @param inputRegisters Input field registers with data needed for
    *        computation.
    * @param outputRegisters Registers that kernel writes with its result.
    */
  case class Step(inputTriggers: Seq[CLEvent],
                  outputTrigger: CLUserEvent,
                  inputRegisters: Array[OpenCLFieldRegister],
                  outputRegisters: Array[OpenCLFieldRegister])
}